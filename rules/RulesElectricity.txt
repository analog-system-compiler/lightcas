/*******************************************************************************/
/*  Copyright (C) 2014 The LightCAS project                                    */
/*                                                                             */
/*  This program is free software; you can redistribute it and/or modify       */
/*  it under the terms of the GNU General Public License as published by       */
/*  the Free Software Foundation; either version 2 of the License, or          */
/*  (at your option) any later version.                                        */
/*                                                                             */
/*  This program is distributed in the hope that it will be useful,            */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of             */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              */
/*  GNU General Public License for more details.                               */
/*                                                                             */
/*  You should have received a copy of the GNU General Public License          */
/*  along with this program; if not, write to the Free Software                */
/*  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
/*******************************************************************************/

UNIT_p( a ) "a$p";
UNIT_n( a ) "a$n";
UNIT_u( a ) "a$u";
UNIT_m( a ) "a$m";
UNIT_k( a ) "a$k";
UNIT_K( a ) "a$K";
UNIT_M( a ) "a$M";
UNIT_G( a ) "a$G";

UNIT_p(a) := a * 1e-12;
UNIT_n(a) := a * 1e-9;
UNIT_u(a) := a * 1e-6;
UNIT_m(a) := a * 1e-3;
UNIT_k(a) := a * 1e3;
UNIT_K(a) := a * 1e3;
UNIT_M(a) := a * 1e6;
UNIT_G(a) := a * 1e9;

t := TIME();

AC(a;b)       := (AC(a);AC(b));
AC(a+b)       := AC(a)+AC(b);
AC(a-b)       := AC(a)-AC(b);
AC(a*b)       := AC(a)*AC(b);
AC(a/b)       := AC(a)/AC(b);
AC(-a)        := -AC(a);
AC(SRC())     := 1;
AC(DER(a,TIME()))  := a*p;
AC(INT(a,TIME()))  := a/p;
AC(TIME())         := 0;
AC(ELEM(a))   := a;
AC(CONST(a))  := a;
AC(a)         := a;

ACROSS( a, a)                            := 0;
LOOP_CHECK(a-ACROSS(c,d);b-ACROSS(c,e))  := (b-a)-ACROSS(d,e);
LOOP_CHECK(a-ACROSS(c,d);b-ACROSS(d,e))  := (a+b)-ACROSS(c,e);
LOOP_CHECK(a;b;c)                        := (LOOP_CHECK(a;c);LOOP_CHECK(b;c));
LOOP_CHECK(a;b)                          := a;

LOOP_TRANS(a;b;c-ACROSS(d))              := LOOP_TRANS( LOOP_CHECK(a;c-ACROSS(d)); LOOP_CHECK(b;c-ACROSS(d)) );
LOOP_TRANS(a;b;c)                        := (LOOP_TRANS(a;b);c);
LOOP_TRANS(a;c-ACROSS(d))                := LOOP_CHECK(a;c-ACROSS(d));
LOOP_TRANS(a)                            := a;

NODE_ADD( NODE(b,c),NODE(d,c)  )         := NODE(d+b,c);
NODE_ADD( NODE(b,_none),NODE(d,_none)  ) := (NODE(b,_none),NODE(d,_none));
NODE_ADD( NODE(b,c),NODE(d,e)  )         := (NODE(b,c),NODE(d,e));

NODE_ADD( a,NODE(b,c),NODE(d,c)  )       := NODE_ADD( a,NODE(d+b,c) );
NODE_ADD( a,NODE(b,c),NODE(d,e)  )       := ( NODE_ADD(a,NODE(d,e)), NODE(b,c) );

NODE_TRANS2(LOOP_TRANS(a))               := NODE_TRANS2(LOOP_TRANS(a)); //just to activate LOOP_TRANS
NODE_TRANS2(d;a-THROUGH(b,c))            := NODE_ADD( NODE_ADD( NODE_TRANS2(d), NODE(a,b)) ,NODE(-a,c) );
NODE_TRANS2(a;b)                         := ( NODE_TRANS2(a), NODE(b,_none) );
NODE_TRANS2(a-THROUGH(b,c))              := ( NODE(a,b) ,NODE(-a,c) );
NODE_TRANS2(a)                           := NODE(a,_none);

INODE_TRANS(a,b)                         := (INODE_TRANS(a);INODE_TRANS(b));
INODE_TRANS(NODE(b,c))                   := b;

INODE_REMOVE(a,NODE(b,_none))            := (INODE_REMOVE(a),NODE(b,_none));
INODE_REMOVE(a,NODE(b,c))                := a;
INODE_REMOVE(a)                          := a;

NODE_TRANS(a)                            := INODE_TRANS( INODE_REMOVE( NODE_TRANS2( a ) ) );

POLY( ACROSS( a, b ), c )  := POLYF( ACROSS(  _get(a), _get(b) ) );
POLY( THROUGH( a, b ), c ) := POLYF( THROUGH( _get(a), _get(b) ) );

//Components definition
NAME.CV(@1,@2,V) := HCV(NAME,@1,@2,V);
NAME.CR(@1,@2,R) := HCR(NAME,@1,@2,R);
NAME.CL(@1,@2,L) := HCL(NAME,@1,@2,L);
NAME.CC(@1,@2,C) := HCC(NAME,@1,@2,C);

HCV(NAME,@1,@2,V) := { NAME.U=ACROSS(@1,@2); NAME.I=THROUGH(@1,@2); NAME.U=V };
HCR(NAME,@1,@2,R) := { NAME.U=ACROSS(@1,@2); NAME.I=THROUGH(@1,@2); NAME.U=R*NAME.I };
HCL(NAME,@1,@2,L) := { NAME.U=ACROSS(@1,@2); NAME.I=THROUGH(@1,@2); NAME.U=L*DER(NAME.I,t) };
HCC(NAME,@1,@2,C) := { NAME.U=ACROSS(@1,@2); NAME.I=THROUGH(@1,@2); NAME.I=C*DER(NAME.U,t) };

FLAT_HIER2({a};{c})   := (c;a);
FLAT_HIER2({a;b};{c}) := FLAT_HIER2({a};{c;b});

FLAT_HIER3({a};{c})   :=               FLAT_HIER2({a};{c});
FLAT_HIER3(a;{b};{c}) := FLAT_HIER3(a;{FLAT_HIER2({b};{c})});
FLAT_HIER({a})        := FLAT_HIER3(a);

ZERO_EQU(a=b) := a-b;
ZERO_SYS(a)   := ZERO_EQU(a);
ZERO_SYS(a;b) := (ZERO_SYS(a);ZERO_EQU(b));

VECT_TO_CONCAT(a;b) := (VECT_TO_CONCAT(a),b);
VECT_TO_CONCAT({a}) := {VECT_TO_CONCAT(a)};
VECT_TO_CONCAT(a)   := a;

//Define RLC circuit for testing purposes
RLC()  := { 
    V.CV(@1,@2,10); 
    R.CR(@2,@3,100); 
    L.CL(@3,@4,1m); 
    C.CC(@4,@1,10u) 
};

RLC1()       := FLAT_HIER(RLC);
RLC2()       := ZERO_SYS(RLC1);
RLC3()       := NODE_TRANS(RLC2);
RLC4()       := LOOP_TRANS(RLC3);
AC_RLC()     := AC(RLC4);
SOLVE_RLC()  := SYSTEM_AUTO_SOLVE({AC_RLC});
SOLVE_RLC2() := SYSTEM_SOLVE(VECT_TO_CONCAT({AC_RLC}),{C.U,V.U,R.U,L.U,R.I,V.I,C.I,L.I})